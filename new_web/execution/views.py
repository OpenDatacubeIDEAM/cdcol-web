# -*- coding: utf-8 -*-

from django.db.models import Avg,Sum
from django.views.generic.base import TemplateView
from django.views.generic.edit import CreateView
from django.views.generic.list import ListView
from django.shortcuts import get_object_or_404
from django.shortcuts import render
from django.conf import settings
from django.core import serializers
from django.http import HttpResponse

from rest_framework import viewsets
from execution.serializers import ExecutionSerializer
from execution.forms import VersionSelectionForm
from execution.models import Execution
from execution.models import Review
from algorithm.models import VersionStorageUnit
from algorithm.models import Parameter
from algorithm.models import Algorithm
from algorithm.models import Version
from algorithm.models import Topic


class ExecutionIndexView(TemplateView):
    """Display a list of the algorithms."""
    template_name = 'execution/index.html'

    def get_context_data(self,**kwargs):
    	"""Add extra content data to the context."""
    	context = super(ExecutionIndexView, self).get_context_data(**kwargs)
    	temporizer = settings.WB_EXECUTION_INDEX_TEMPORIZER
    	context['temporizer_value'] = temporizer
    	return context


class ExecutionViewSet(viewsets.ModelViewSet):
    """CRUD over Algoritm model via API calls."""
    queryset = Execution.objects.all()
    serializer_class = ExecutionSerializer

    def get_queryset(self):
        """Filter the queryset depending of the user.
        
        Executions created by the current user will be 
        retrieved, but also the 'state' of the retrieved 
        executions must be Execution.ENQUEUED_STATE.
        """
        current_user = self.request.user
        queryset = super().get_queryset().filter(executed_by=current_user)

        return queryset


class AlgorithmsByTopicListView(ListView):
    """List algorithms by topic to be selected for execution."""
    
    model = Topic
    context_object_name = 'topics'
    template_name = 'execution/algorithms_by_topic_list.html'

    def get_queryset(self,**kwargs):
        """
        Return the topic which have algorithms which has 
        some version in published state.
        """
        queryset = super().get_queryset().filter(
            algorithm__version__publishing_state=Version.PUBLISHED_STATE,
            enabled=True
        )
        return queryset


# class ExecutionCreateView(CreateView):
#     """Create a new execution 

#     Create a new execution given the id of the last version
#     for an algorithm.

#     Use the template execution/execution_form.html
#     """
#     model = Execution

#     def get_initial(self):
#         """Return the initial data for the execution form generated by django."""

#         last_version_pk = self.kwargs.get('pk')
#         last_version = get_object_or_404(Version,pk=last_version_pk)
#         data = { 'version': last_version }
#         return data


# def get_detail_context(execution_id):
#     execution = get_object_or_404(Execution, id=execution_id)
#     executed_params = ExecutionParameter.objects.filter(execution=execution).order_by('parameter__position')
#     tasks = Task.objects.filter(execution=execution)
#     area_param = ExecutionParameter.objects.get(execution=execution, parameter__parameter_type=Parameter.AREA_TYPE)
#     time_period_param = ExecutionParameter.objects.filter(execution=execution, parameter__parameter_type=Parameter.TIME_PERIOD_TYPE).order_by('parameter__position')
#     time_period_params_string = ""
#     for time_period in time_period_param:
#         time_period_params_string+='(u{}u{})'.format(time_period.timeperiodtype.start_date.strftime("%d-%m-%Y"), time_period.timeperiodtype.end_date.strftime("%d-%m-%Y") )
#     review = Review.objects.filter(execution=execution).last()
#     system_path = "{}/results/{}/".format(settings.WEB_STORAGE_PATH, execution.id)
#     files = []
#     other_files = []

#     try:
#         algorithm_name= slugify(unidecode.unidecode(execution.version.algorithm.name.lower()))
#         tiff_message = None
#         generating_tiff = '0'
#         print int(area_param.areatype.latitude_start)

#         for i in range(int(area_param.areatype.latitude_start), int(area_param.areatype.latitude_end)):

#             for j in range(int(area_param.areatype.longitude_start), int(area_param.areatype.longitude_end)):
#                 file_name= '{}_{}_{}_{}_{}_output.nc'.format(algorithm_name, execution.version.number, i, j, time_period_params_string)
#                 f = {'file': file_name, 'lat': i, 'long': j, 'task_state': '', 'result_state': os.path.exists(system_path+file_name), 'state': False, 'tiff_file': file_name.replace('.nc', '.tiff')}
#                 if f['result_state']:
#                     f['task_state'] = 'Finalizado'
#                 elif (os.path.exists(system_path+"{}_{}_no_data.lock".format(i,j)))  or (execution.state == Execution.COMPLETED_STATE and not f['result_state']):
#                     f['task_state'] = system_path+file_name
#                 elif execution.state == Execution.ENQUEUED_STATE:
#                     f['task_state'] = 'En espera'
#                 elif execution.state == Execution.EXECUTING_STATE:
#                     f['task_state'] = 'En ejecuci贸n'
#                 elif execution.state == Execution.ERROR_STATE:
#                     f['task_state'] = 'Fall贸'
#                 elif execution.state == Execution.CANCELED_STATE:
#                     f['task_state'] = 'Cancelado'
#                 else:
#                     f['task_state'] = 'Sin informaci贸n disp贸nible'
#                 try:
#                     convertion_task = FileConvertionTask.objects.get(execution=execution, filename=f['file'])
#                     f['state'] = convertion_task.state
#                     if f['state'] == '3':
#                         tiff_message='Hubo un error generando el archivo Tiff. Por favor, intente de nuevo'
#                     elif f['state'] == True:
#                         generating_tiff = '1'
#                 except ObjectDoesNotExist:
#                     pass
#                 except MultipleObjectsReturned:
#                     tiff_message = 'Hubo un error generando el archivo Tiff. Por favor, intente de nuevo'
#                     FileConvertionTask.objects.filter(execution=execution, filename=f['file']).delete()
#                 files.append(f)

#         for f in os.listdir(system_path):
#             if ".gif" in f :
#                 f = {'file': f, 'state':False}
#                 other_files.append(f)
#             elif "mosaic" in f and ".nc" in f:
#                 f = {'file': f, 'state': False, 'tiff_file':f.replace('.nc', '.tiff')}
#                 try:
#                     convertion_task = FileConvertionTask.objects.get(execution=execution, filename=f['file'])
#                     f['state'] = convertion_task.state
#                     if f['state'] == '3':
#                         tiff_message = 'Hubo un error generando el archivo Tiff. Por favor, intente de nuevo'
#                     elif f['state'] == True:
#                         generating_tiff = '1'
#                 except ObjectDoesNotExist:
#                     pass
#                 except MultipleObjectsReturned:
#                     tiff_message = 'Hubo un error generando el archivo Tiff. Por favor, intente de nuevo'
#                     FileConvertionTask.objects.filter(execution=execution, filename=f['file']).delete()
#                 other_files.append(f)


#         # for f in os.listdir(system_path):
#         #     if ".tiff" not in f:
#         #         f = {'file': f, 'lat':0, 'long':0, 'state': False, 'tiff_file': f.replace('.nc', '.tiff')}
#         #         try:
#         #             convertion_task = FileConvertionTask.objects.get(execution=execution, filename=f['file'])
#         #             f['state'] = convertion_task.state
#         #         except ObjectDoesNotExist:
#         #             pass
#         #         except MultipleObjectsReturned:
#         #             FileConvertionTask.objects.filter(execution=execution, filename=f['file']).delete()
#         #         files.append(f)
#     except:
#         pass
#     # getting current executions
#     current_executions = execution.pending_executions
#     # getting temporizer value
#     temporizer_value = settings.IDEAM_TEMPORIZER
#     # getting the delete time
#     delete_hours = int(settings.DAYS_ELAPSED_TO_DELETE_EXECUTION_RESULTS) * 24
#     if execution.finished_at:
#         delete_time = execution.finished_at + datetime.timedelta(hours=delete_hours)
#     else:
#         delete_time = None
#     context = {'execution': execution, 'executed_params': executed_params, 'review': review, 'files': files, 'other_files': other_files,
#                'current_executions': current_executions, 'temporizer_value': temporizer_value, 'delete_time': delete_time,
#                'system_path': system_path, 'area_param':area_param, 'time_period_param':time_period_param, 'tiff_message':tiff_message, 'generating_tiff': generating_tiff}
#     return context


class ExecutionCreateView(TemplateView):
    """
    An execution is created given an algorithm. 
    The last version of the algorithm is always 
    considered on this view to create an Execution.
    """

    def get(self,request,*args,**kwargs):

        # Getting the version to be executed
        version_pk = kwargs.get('pk')
        version = get_object_or_404(Version, pk=version_pk)

        # Current user
        current_user = request.user

        # User approved credits
        credits_approved = current_user.profile.credits_approved

        # Getting the number of credicts used.
        states = [Execution.ENQUEUED_STATE, Execution.EXECUTING_STATE]
        credits_used = current_user.execution_set.filter(
            state__in=states
        ).aggregate(Sum('credits_consumed'))

        # New number of credists available for the user.
        credits_consumed = credits_used['credits_consumed__sum']
        if credits_consumed:
            credits_approved -= credits_consumed

        # Version selection form
        version_selection_form = VersionSelectionForm(
            algorithm=version.algorithm,user=request.user
        )

        storage_units_version = VersionStorageUnit.objects.filter(
            version__algorithm=version.algorithm
        )

        parameters = Parameter.objects.filter(
            version=version, enabled=True
        ).order_by('position')

        reviews = Review.objects.filter(execution__version=version)

        # getting the average rating
        average_rating = Review.objects.filter(
            execution__version=version
        ).aggregate(Avg('rating'))['rating__avg']
        average_rating = round(average_rating if average_rating is not None else 0, 2)

        executions = Execution.objects.filter(version=version)

        topics = Topic.objects.filter(enabled=True)

        executed_params = []

        context = {
            'topics': topics, 
            'algorithm': version.algorithm, 
            'parameters': parameters,
            'version_selection_form': version_selection_form, 
            'version': version,
            'reviews': reviews,
            'average_rating': average_rating, 
            'executions': executions,
            'executed_params': executed_params, 
            'credits_approved': credits_approved,
            # return this parameter as a list is mandatory for
            # /static/js/formBuilder.js works properly
            'storage_units_version':list(storage_units_version)
        }

        return render(request, 'execution/execution_form.html', context)


class VersionParametersJson(TemplateView):

    def get(self,request,*args,**kwargs):

        version_id = kwargs.get('pk')
        parameters = Parameter.objects.filter(
            version__id=version_id, enabled=True
        ).order_by('position')

        data = serializers.serialize(
            "json", parameters
        )
        return HttpResponse(data, content_type='application/json')